---
title: "Replication Code"
subtitle: "'Strong Ties and Stable Jobs: Occupational Embeddedness in the Labor Market'"
author: Lydia Camp
date: last-modified
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    code-fold: true
    code-summary: "Show code"
    code-copy: true
    code-overflow: wrap
execute:
  eval: false
  echo: true
  warning: false
  message: false
---

# Import Data/Packages

```{r}
# Load Packages
library(tidyverse)
library(lmtest)
library(sandwich)
library(fixest)
library(did)
library(panelView)
library(car)
library(showtext)
library(grid)
library(data.table)
library(FNN)
library(stringr)
library(plm)
library(scales)
library(modelsummary)
library(devtools)
library(foreign)
library(stargazer) 
library(effectsize)
library(MASS)
library(marginaleffects)
library(broom)
library(readxl)
library(igraph)
library(tidygraph)
library(ggraph)
library(patchwork)
library(showtext)
library(httr2)
library(jsonlite)
library(purrr)
library(openai)
```

```{r}
# Function for cleaning the data (provided by GSS)
 read.dct <- function(dct, labels.included = "yes") {
      temp <- readLines(dct)
      temp <- temp[grepl("_column", temp)]
      switch(labels.included,
             yes = {
                 pattern <- "_column\\(([0-9]+)\\)\\s+([a-z0-9]+)\\s+(.*)\\s+%([0-9]+)[a-z]\\s+(.*)"
                 classes <- c("numeric", "character", "character", "numeric", "character")
                 N <- 5
                 NAMES <- c("StartPos", "Str", "ColName", "ColWidth", "ColLabel")
             },
             no = {
                 pattern <- "_column\\(([0-9]+)\\)\\s+([a-z0-9]+)\\s+(.*)\\s+%([0-9]+).*"
                 classes <- c("numeric", "character", "character", "numeric")
                 N <- 4
                 NAMES <- c("StartPos", "Str", "ColName", "ColWidth")
             })
      temp_metadata <- setNames(lapply(1:N, function(x) {
          out <- gsub(pattern, paste("\\", x, sep = ""), temp)
          out <- gsub("^\\s+|\\s+$", "", out)
          out <- gsub('\"', "", out, fixed = TRUE)
          class(out) <- classes[x] ; out }), NAMES)
      temp_metadata[["ColName"]] <- make.names(gsub("\\s", "", temp_metadata[["ColName"]]))
      temp_metadata
  }

  read.dat <- function(dat, metadata_var, labels.included = "yes") {
      read.table(dat, col.names = metadata_var[["ColName"]])
  }

# Load the data
GSS_metadata <- read.dct("GSS.dct")
GSS_ascii <- read.dat("GSS.dat", GSS_metadata)
attr(GSS_ascii, "col.label") <- GSS_metadata[["ColLabel"]]
GSS <- GSS_ascii
```

# Theoretical Framework

```{r}
make_overlap_graph <- function(n_personal_total = 18,
                               n_work_total     = 18,
                               n_both           = 0,
                               p_within         = 0.55,
                               separation       = 3.0,
                               seed             = 1) {
  set.seed(seed)

  stopifnot(n_both <= min(n_personal_total, n_work_total))

  n_personal_only <- n_personal_total - n_both
  n_work_only     <- n_work_total - n_both

  nodes <- bind_rows(
    tibble(name = "Respondent", group = "Respondent"),
    tibble(name = paste0("P", seq_len(n_personal_only)), group = "Personal"),
    if (n_both > 0) tibble(name = paste0("B", seq_len(n_both)), group = "Both"),
    tibble(name = paste0("W", seq_len(n_work_only)), group = "Work")
  ) |> 
    mutate(group = as.character(group)) 

  # helper: random within-edges
  rand_edges <- function(vec, p) {
    if (length(vec) < 2) return(tibble(from = character(), to = character()))
    pairs <- t(combn(vec, 2))
    keep <- runif(nrow(pairs)) < p
    if (!any(keep)) return(tibble(from = character(), to = character()))
    tibble(from = pairs[keep, 1], to = pairs[keep, 2])
  }

  edges <- tibble(from = character(), to = character(), type = character())

  # Respondent connected to all alters
  edges <- bind_rows(
    edges,
    tibble(
      from = "Respondent",
      to   = nodes$name[nodes$name != "Respondent"],
      type = "ego"
    )
  )

  # Define spheres 
  personal_cluster <- nodes$name[nodes$group %in% c("Personal", "Both")]
  work_cluster     <- nodes$name[nodes$group %in% c("Work", "Both")]

  # within-sphere edges
  edges <- bind_rows(
    edges,
    rand_edges(personal_cluster, p_within) |>  mutate(type = "within"),
    rand_edges(work_cluster, p_within) |> mutate(type = "within")
  )

  g <- graph_from_data_frame(edges, directed = FALSE, vertices = nodes)
  lay <- layout_with_fr(g)
  rownames(lay) <- V(g)$name

  lay["Respondent", ] <- c(0, 0)

  personal_names <- nodes$name[nodes$group == "Personal"]
  work_names     <- nodes$name[nodes$group == "Work"]
  both_names     <- nodes$name[nodes$group == "Both"]

  if (length(personal_names) > 0) lay[personal_names, 1] <- lay[personal_names, 1] - separation
  if (length(work_names)     > 0) lay[work_names, 1]     <- lay[work_names, 1] + separation

  # keep Both near center with small jitter
  if (length(both_names) > 0) {
    lay[both_names, 1] <- lay[both_names, 1] + rnorm(length(both_names), 0, 0.15)
    lay[both_names, 2] <- lay[both_names, 2] + rnorm(length(both_names), 0, 0.15)
  }

  list(g = g, layout = lay)
}


# Create the function for making the plot
plot_overlap <- function(obj, oe_label, show_legend = TRUE) {
  cols <- c(
    "Respondent" = "black",
    "Personal"   = "#D73027",  
    "Work"       = "#4575B4", 
    "Both"       = "#7B3294"   
  )

  sizes <- c(
    "Respondent" = 7.2,
    "Personal"   = 3.9,
    "Work"       = 3.9,
    "Both"       = 5
  )

  tg <- as_tbl_graph(obj$g) |> 
    activate(nodes) |> 
    mutate(group = as.character(group))  
  xr <- range(obj$layout[,1])
  yr <- range(obj$layout[,2])
 lx <- xr[1] - 0.20 * diff(xr)   # position the labels
ly <- yr[2] + 0.15 * diff(yr)   

  ggraph(tg, layout = "manual",
         x = obj$layout[,1], y = obj$layout[,2]) +
    geom_edge_link(colour = "grey65", alpha = 0.30, linewidth = 0.45) +
    geom_node_point(aes(colour = group, size = group), alpha = 0.95) +
    scale_colour_manual(
  values = cols,
  breaks = names(cols),
  limits = names(cols),
  drop   = FALSE,
  labels = c("Respondent", "Personal", "Work", "Both")
) +
    coord_cartesian(clip = "off") +
      scale_size_manual(values = sizes, limits = names(sizes), breaks = names(sizes)) +
    annotate("text", x = lx, y = ly, label = oe_label,
         hjust = 0, vjust = 0,
         fontface = "bold",
         family = "Times New Roman",
         size = 6) +
   guides(colour = guide_legend(override.aes = list(size = 6)), size = "none") +
    theme_void() +
    theme(
      legend.position = if (show_legend) "right" else "none",
      legend.title = element_blank(),
      legend.text = element_text(size = 15),
legend.key.size = unit(1.2, "lines"),
text = element_text(family = "Times New Roman"),
plot.margin = margin(t = 40, r = 20, b = 20, l = 40)
    )
}

# Create 3 scenarios
g0  <- make_overlap_graph(n_both = 0,  separation = 3.4, seed = 1)
g05 <- make_overlap_graph(n_both = 12, separation = 2.0, seed = 8)
g1  <- make_overlap_graph(n_both = 18, separation = 0.0, seed = 5)

# Plot
p0  <- plot_overlap(g0,  oe_label = "(a) OE Score = 0.0",   show_legend = FALSE)
p05 <- plot_overlap(g05, oe_label = "(b) OE Score = 0.5", show_legend = FALSE)
p1  <- plot_overlap(g1,  oe_label = "(c) OE Score = 1.0",   show_legend = TRUE)

fig <- (p0 / p05 / p1) + plot_layout(guides = "collect")
fig

# Save
# ggsave("oe_overlap_panels.png", fig, width = 7.5, height = 10, dpi = 300)
```

![](images/oe_overlap_panels.png)

# Clean Data

```{r}
# set years
data <- GSS |> 
  filter(YEAR == 2004) # data available only in 2004

# Make missing values NA (function for cleaning data)
clean_negatives <- function(x) {
  x[x < 0] <- NA
  return(x)
}
data <- clean_negatives(data)

# remove variables not in dataset
data2 <- data |>
  filter(!(is.na(SEX1) & is.na(SEX2) & is.na(SEX3) & is.na(SEX4) & is.na(SEX5)))
# remove observations that have NAs for all five contacts


# Clean Variables 
data3 <- data2 %>%
  mutate(
    female = case_when(SEX == 2 ~ 1, SEX == 1 ~ 0),
    black = case_when(RACE == 2 ~ 1, RACE == 1 ~ 0, RACE == 3 ~ 0),
    latinx = case_when(HISPANIC == 2 ~ 1, HISPANIC == 3 ~ 1, HISPANIC == 4 ~ 1, HISPANIC == 5 ~ 1, HISPANIC == 1 ~ 0),
    migrant = case_when(BORN == 2 ~ 1, BORN == 1 ~ 0),
    income = RINCOME,
    hsincome = INCOME,
    age = AGE,
    educ = EDUC,
    marital = MARITAL,
    region = case_when(REGION == 3 ~ 1, TRUE~0),
    partyid = 7 - PARTYID,
    work = case_when(WRKSTAT == 1 ~ 1, WRKSTAT==2~1, WRKSTAT==3~1, TRUE~0),
    rural = case_when(SRCBELT == 6 ~ 1, TRUE~0),
    union = case_when(UNION_ == 1 ~1,
                      TRUE~0),
    joblike_lose = 5 - JOBLOSE,
    hrs_week = HRS1,
    hrs_week2 = HRS2,
    job_cwrk = JOBCOWRK,
    job_find = 4 - JOBFIND,
    born = BORN,
    talkto1 = 5 - TALKTO1,
     talkto2 = 5 - TALKTO2,
     talkto3 = 5 - TALKTO2,
     talkto4 = 5 - TALKTO2,
     talkto5 = 5 - TALKTO2,
    work_govt = case_when(WRKGOVT == 1 ~ 1,
                          WRKGOVT == 2 ~ 0),
    cowork1 = case_when(COWORK1 == 1 ~1,
                        COWORK1 == 2 ~ 0),
    cowork2 = case_when(COWORK2 == 1 ~1,
                        COWORK2 == 2 ~ 0),
    cowork3 = case_when(COWORK3 == 1 ~1,
                        COWORK3 == 2 ~ 0),
    cowork4 = case_when(COWORK4 == 1 ~1,
                        COWORK4 == 2 ~ 0),
    cowork5 = case_when(COWORK5 == 1 ~1,
                        COWORK5 == 2 ~ 0),
    help_find_job = 7 - HELPJOB,
    childs = CHILDS,
    occ10_code = OCC10,
    sat_job = 5 - SATJOB,
    numgiven = NUMGIVEN, # total number of contacts
    prop_cowork = rowSums(across(c(cowork1, cowork2, cowork3, cowork4, cowork5)), 
                           na.rm = TRUE) / numgiven,
   isco1 = as.numeric(substr(as.character(ISCO88), 1, 1)), # 1-9 occ code
   isco2 = as.numeric(substr(as.character(ISCO88), 1, 2)), 
   sub_class = case_when(
      CLASS_ == 1 ~ "Lower class",
      CLASS_ == 2 ~ "Working class",
      CLASS_ == 3 ~ "Middle class",
      CLASS_ == 4 ~ "Upper class",
      TRUE ~ NA_character_
    ),
   job_sec = 5 - GDJOBSEC,
    race = factor(
      case_when(
        HISPANIC != 1 ~ "Latinx",
        RACE == 1 & HISPANIC == 1 ~ "White-NonLatinx",
        RACE == 2 & HISPANIC == 1 ~ "Black-NonLatinx",
        RACE == 3 & HISPANIC == 1 ~ "Other-NonLatinx"
      ),
      levels = c("White-NonLatinx", "Black-NonLatinx", "Latinx", "Other-NonLatinx")
    )
  )
```

## Create Weighted Network Measure

```{r}
# Weight networks by the intensity of contact
data3 <- data3 |>
  rowwise() |>
  mutate(
    weighted_cowork = if (!is.na(numgiven) && numgiven > 0) {

      cw <- c(cowork1, cowork2, cowork3, cowork4, cowork5)[1:numgiven]
      tk <- c(talkto1, talkto2, talkto3, talkto4, talkto5)[1:numgiven]

      num <- sum(cw * tk, na.rm = TRUE)
      den <- sum(tk, na.rm = TRUE)

      if (den > 0) num / den else NA_real_

    } else {
      NA_real_
    }
  ) |>
  ungroup()
```

## Match By OCC 10 titles

```{r}
# Official Census 2010 occupation code list (with crosswalk file)
occ_url <- "https://www2.census.gov/programs-surveys/demo/guidance/industry-occupation/2010-occ-codes-with-crosswalk-from-2002-2011.xls"

tmp <- tempfile(fileext = ".xls")
download.file(occ_url, tmp, mode = "wb")

# Read the Excel and keep the 2010 code + title columns
occ_lu_raw <- read_excel(tmp)

occ10_lu <- occ_lu_raw |>
  transmute(
    occ10_code  = str_trim(as.character(`...3`)),
    occ10_title = str_squish(as.character(`US Census Bureau`))
  ) |>
  filter(str_detect(occ10_code, "^\\d{4}$")) |>
  mutate(
    occ10_code = as.integer(occ10_code)
  )

# join onto your data 
data3 <- data3 |>
  left_join(occ10_lu, by = "occ10_code")
```

## Create ISCO 1-Digit and 2-Digit Labels

```{r}
# BY 1-DIGIT OCC CODE
isco88_1digit <- tibble::tribble(
  ~isco1, ~isco1_title,
  0, "Armed forces",
  1, "Legislators, senior officials and managers",
  2, "Professionals",
  3, "Technicians and associate professionals",
  4, "Clerks",
  5, "Service workers and shop and market sales workers",
  6, "Skilled agricultural and fishery workers",
  7, "Craft and related trades workers",
  8, "Plant and machine operators and assemblers",
  9, "Elementary occupations"
)

data3 <- data3 |>
  left_join(isco88_1digit, by = "isco1")



# BY 2-DIGIT OCC CODE
# ISCO-88: 2-digit sub-major groups
isco88_2digit <- tibble::tribble(
  ~isco2, ~isco2_title,
  11, "Legislators and senior officials",
  12, "Corporate managers",
  13, "General managers",
  21, "Physical, mathematical and engineering science professionals",
  22, "Life science and health professionals",
  23, "Teaching professionals",
  24, "Other professionals",
  31, "Physical and engineering science associate professionals",
  32, "Life science and health associate professionals",
  33, "Teaching associate professionals",
  34, "Other associate professionals",
  41, "Office clerks",
  42, "Customer services clerks",
  51, "Personal and protective services workers",
  52, "Models, salespersons and demonstrators",
  61, "Market-oriented skilled agricultural and fishery workers",
  62, "Subsistence agricultural and fishery workers",
  71, "Extraction and building trades workers",
  72, "Metal, machinery and related trades workers",
  73, "Precision, handicraft, craft printing and related trades workers",
  74, "Other craft and related trades workers",
  81, "Stationary-plant and related operators",
  82, "Machine operators and assemblers",
  83, "Drivers and mobile-plant operators",
  91, "Sales and services elementary occupations",
  92, "Agricultural, fishery and related labourers",
  93, "Labourers in mining, construction, manufacturing and transport"
)

data3 <- data3 |>
  left_join(isco88_2digit, by = "isco2")

```

## Create EGP Schema

```{r}
# install once
install.packages("remotes")
remotes::install_github("pdparker/isco88conversion")

library(isco88conversion)

data3$EGP <- isco88conversion::convert(data3$ISCO88, type = "EGP")

egp_labels <- c(
  "Higher-grade service class",
  "Lower-grade service class",
  "Routine non-manual workers",
  "Small proprietors (non-agricultural)",
  "Lower technicians / skilled manual supervisors",
  "Self-employed",
  "Skilled manual workers",
  "Semi- and unskilled manual workers",
  "Agricultural workers",
  "Farmers",
  "Agricultural self-employed"
)

data3$EGP_title <- factor(
  data3$EGP,
  levels = 1:11,
  labels = egp_labels
)
```

# Descriptive Statistics

## Weighted Coworker Measure

```{r}
data4 <- data3 |> 
  filter(work == 1)
## OF THOSE WHO WORK
# BY CLASS
data4 |>
  group_by(sub_class) |>
  summarise(
    avg_prop_cowork = 100*mean(weighted_cowork, na.rm = TRUE),
    n = n()
  )
# more of a working and middle class pheonomenon (in terms of self-reported class identity)

# BY 1-DIGIT OCC CODE
data4 |>
  group_by(isco1_title) |>
  summarise(
    avg_prop_cowork = 100*mean(weighted_cowork, na.rm = TRUE),
    n = n()
  ) |> 
  arrange(desc(avg_prop_cowork))
```

### By ISCO 2 Digit

```{r}
data4 |>
  group_by(isco2_title) |>
  summarise(
    avg_prop_cowork = 100*mean(weighted_cowork, na.rm = TRUE),
    n = n()
  ) |> 
    arrange(desc(avg_prop_cowork))

```

### By OCC 10

```{r}
data4 |>
  group_by(occ10_title) |>
  summarise(
    avg_prop_cowork = 100 * mean(weighted_cowork, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) |>
  arrange(desc(avg_prop_cowork))

```

### By EGP

```{r}
data4 |>
  group_by(EGP_title) |>
  summarise(
    avg_prop_cowork = 100*mean(weighted_cowork, na.rm = TRUE),
    n = n()
  ) |> 
    arrange(desc(avg_prop_cowork))
```

![](images/OE-score.png)

## Perceptions of Job Loss

```{r}

data4 <- data3 |> 
  filter(work == 1)
# BY CLASS
data4 |>
  group_by(sub_class) |>
  summarise(
    avg_prop_cowork = mean(joblike_lose, na.rm = TRUE),
    n = n()
  )
# BY OCCUPATION
data3 |>
  group_by(occ_major) |>
  summarise(
    avg_prop_cowork = mean(joblike_lose, na.rm = TRUE),
    n = n()
  )
```

# Run Regressions

```{r}
# likelihood of losing job
m1a <- lm(joblike_lose ~ weighted_cowork + female + age + I(age^2) + educ + marital + CHILDS + hsincome + race + rural + union + region + work_govt + log(hrs_week) + migrant + factor(isco1) + partyid + sat_job, data = data3) # isco 1 digit FE

m1b <- lm(joblike_lose ~ weighted_cowork + female + age + I(age^2) + educ + marital + CHILDS + hsincome + race + rural + union + region + work_govt + log(hrs_week) + migrant + EGP_title + partyid + sat_job + factor(isco1), data = data3) # EGP FE and ISCO 1 DIGIT FE
summary(m1b)

# Extract exact estimation sample used by m1
mf_m1 <- model.frame(m1a)

# Re-run pure model on same sample
m1_pure <- lm(joblike_lose ~ weighted_cowork, data = mf_m1)


# likelihood of losing job
m2a <- lm(job_sec ~ weighted_cowork + female + age + I(age^2) + educ + marital + CHILDS + hsincome + race + rural + union + region + work_govt + log(hrs_week) + migrant + factor(isco1) + partyid + sat_job, data = data3) # isco 1 digit FE
summary(m2a)

m2b <- lm(job_sec ~ weighted_cowork + female + age + I(age^2) + educ + marital + CHILDS + hsincome + race + rural + union + region + work_govt + log(hrs_week) + migrant + EGP_title + partyid + sat_job + factor(isco1), data = data3) # EGP FE and ISCO 1 DIGIT FE
summary(m2b)

# Extract exact estimation sample used by m1
mf_m2 <- model.frame(m2a)

# Re-run pure model on same sample
m2_pure <- lm(job_sec ~ weighted_cowork, data = mf_m2)
```

## Robustness Checks

```{r}
# Test Heteroskedasticity
bptest(m2) # not heteroskedastic
bptest(m1) # not heteroskedastic
```

## Final Table

```{r}
# define models
models <- list(
   "Job Loss" = m1_pure,
  "Job Loss" = m1a,
  "Job Loss" = m1b,
   "Job Security" = m2_pure,
  "Job Security" = m2a,
  "Job Security" = m2b
)

# define variable names
coef_map <- c(
  "weighted_cowork" = "Weighted coworker share",
  "female" = "Female",
  "age" = "Age",
  "I(age^2)" = "Age squared",
  "educ" = "Education",
  "marital" = "Married",
  "CHILDS" = "Children",
  "hsincome" = "Household income",
  "race" = "Race",
  "rural" = "Rural",
  "union" = "Union member",
  "work_govt" = "Government worker",
  "hrs_week" = "Hours worked per week",
  "born" = "US-born",
  "partyid" = "Party ID"
)

# table
modelsummary(
  models,
 # vcov = vcovHC,
  statistic = "std.error",
  coef_rename = coef_map,
  stars = TRUE,
  gof_omit = "IC|Log|Adj|F",
 output = "latex"
)
```

```{r}
# Descriptive table
# Extract data actually used in the model
mf <- model.frame(m1)

# Descriptives for numeric variables
descriptives <- data.frame(
  N    = sapply(mf, function(x) sum(!is.na(x))),
  Mean = sapply(mf, function(x) if (is.numeric(x)) mean(x, na.rm = TRUE) else NA),
  SD   = sapply(mf, function(x) if (is.numeric(x)) sd(x, na.rm = TRUE) else NA),
  Min  = sapply(mf, function(x) if (is.numeric(x)) min(x, na.rm = TRUE) else NA),
  Max  = sapply(mf, function(x) if (is.numeric(x)) max(x, na.rm = TRUE) else NA)
)

descriptives
```

# Visualization

```{r}
# if half of your close friends are your co-workers

# Prediction grid
grid <- datagrid(
  model = m2a,
  weighted_cowork = c(0, 0.5, 1)
)

pred <- predictions(
  m2a,
  newdata = grid,
  conf_level = 0.95
)

ggplot(pred, aes(x = weighted_cowork, y = estimate)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.08,
    linewidth = 1
  ) +
  geom_point(size = 3) +
  scale_x_continuous(
    breaks = c(0, 0.5, 1),
    labels = c("0 (Low)", "0.5 (Medium)", "1 (High)")
  ) +
  scale_y_continuous(
    limits = c(1, 5),
    breaks = 1:4
  ) +
  labs(
    x = "Coworker Embeddedness (Weighted)",
    y = "Predicted Job Security",
    title = "Predicted Job Security by Coworker Embeddedness",
    subtitle = "Estimates from linear regression with 95% confidence intervals",
    caption = "Predictions averaged over observed covariates"
  ) +
  theme_classic(base_size = 14)

```

```{r}
coefs <- bind_rows(
  tidy(m2_pure, conf.int = TRUE) |> 
    mutate(model = "Without Controls"),
  tidy(m2a, conf.int = TRUE) |>  
    mutate(model = "With Controls"),
  tidy(m2b, conf.int = TRUE) |>  
    mutate(model = "With Controls + EGP dummies")
) |> 
  filter(term == "weighted_cowork") |> 
  mutate(
    model = factor(
      model,
      levels = c("Without Controls", "With Controls", "With Controls + EGP dummies")
    )
  )

p2 <- ggplot(coefs, aes(x = model, y = estimate, color = model)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.18,
    linewidth = 1.2
  ) +
  geom_point(size = 4) +
  geom_hline(yintercept = 0, linetype = "dotted", linewidth = 1) +
  coord_flip() +
  scale_color_manual(
    values = c(
      "Without Controls" = "black",
      "With Controls" = "blue",
      "With Controls + EGP dummies" = "darkred"
    ),
    guide = "none"
  ) +
  labs(x = NULL, y = "Estimated Coefficient (95% CI)") +
  theme_classic(base_size = 15) +
  theme(
    text = element_text(family = "Times New Roman"),
    axis.title.y = element_text(size = 17, margin = margin(r = 12)),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 15),
    axis.line = element_line(linewidth = 0.9),
    axis.ticks = element_line(linewidth = 0.9)
  )

p2

```

![](images/coef_cowork2.png)

```{r}
coefs <- bind_rows(
  tidy(m1_pure, conf.int = TRUE) |> 
    mutate(model = "Without Controls"),
  tidy(m1a, conf.int = TRUE) |>  
    mutate(model = "With Controls"),
  tidy(m1b, conf.int = TRUE) |>  
    mutate(model = "With Controls + EGP dummies")
) |> 
  filter(term == "weighted_cowork") |> 
  mutate(
    model = factor(
      model,
      levels = c("Without Controls", "With Controls", "With Controls + EGP dummies")
    )
  )

p3 <- ggplot(coefs, aes(x = model, y = estimate, color = model)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.18,
    linewidth = 1.2
  ) +
  geom_point(size = 4) +
  geom_hline(yintercept = 0, linetype = "dotted", linewidth = 1) +
  coord_flip() +
  scale_color_manual(
    values = c(
      "Without Controls" = "black",
      "With Controls" = "blue",
      "With Controls + EGP dummies" = "darkred"
    ),
    guide = "none"
  ) +
  labs(x = NULL, y = "Estimated Coefficient (95% CI)") +
  theme_classic(base_size = 15) +
  theme(
    text = element_text(family = "Times New Roman"),
    axis.title.y = element_text(size = 17, margin = margin(r = 12)),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 15),
    axis.line = element_line(linewidth = 0.9),
    axis.ticks = element_line(linewidth = 0.9)
  )

p3

```

![](images/coef_cowork.png)

# LinkedIn Map ISCO Titles

```{r}
# Load data for my LinkedIn Connections
Connections <- read_csv(".csv")
jobs_raw <- Connections

# Set API key
Sys.setenv(OPENAI_API_KEY = "") # Real key hidden for privacy

# Clean data
df_panel <- Connections |>  mutate(Position = str_squish(Position))
```

## Create Prompt

```{r}
ISCO_RULES <- "
You are a professional annotator of professions, and your task is to classify each position/job title into its actual ISCO-08 4 digit code and label.

Please follow these rules:
1) If it says anything like scholarship or academic award (e.g. Fulbright), then don't give it an ISCO code but an NA. However, if someone clearly indicates that they are an ETA (English Teaching Assistant) or teacher, classify them accordingly.
2) If someone is a current student or \"candidate\" (e.g. if the position includes \"major\" or BA/BS/BBA/MBA/J.D./MA or \"Master's\" etc.), then generally don't give them an ISCO code but also an NA. However, some people may include a previous degree in their position title even though they are currently working, so if you see a real job title in the position as well, then assign the ISCO code based on the occupation and disregard the university degree. Additionally, if you see that someone is a PhD or doctoral candidate, you can assume they are working and code their occupation based on the field of their PhD studies (likely somewhere within the 263 group).
3) If you are unable to classify to the 4 digit level because of ambiguity but you can accurately map to the 3-digit level, then set isco4_code to NA but fill isco3_code and isco3_label.
4) If it says self-employed or entrepreneur without a description of what the person is actually doing, set NA.
5) If it says anything related to worship, assume they are a singer at a religious organization.
6) If title is Spanish, translate to English internally and proceed.
7) If someone is a researcher or \"fellow\" without specifying the field, place them in the university professor category. But if someone is a research assistant, place them within the 263 group if possible; try to classify to 4-digit using context clues.
8) Try your best to find a 4 digit code for all observations, but do not force it. Prefer NA over an obviously wrong answer.

Return ONLY a single JSON object with these keys:
isco4_code (string or null),
isco4_label (string or null),
isco3_code (string or null),
isco3_label (string or null),
position_english (string),
notes (string).
"
```

## Create ISCO-08 Translation Function

```{r}
# Create function
isco_code_one <- function(position, company = NA_character_) {
  # Clean inputs
  position <- position |>  as.character() |>  stringr::str_squish()
  company  <- company  |>  as.character() |>  stringr::str_squish()
  if (is.na(company)) company <- ""

  prompt <- paste0(
    "Classify this job title into ISCO-08.\n\n",
    "POSITION: ", position, "\n",
    "COMPANY: ", company, "\n\n",
    "Output JSON only."
  )

  r <- httr2::request("https://api.openai.com/v1/chat/completions") |>
    httr2::req_headers(
      Authorization = paste("Bearer", Sys.getenv("OPENAI_API_KEY")),
      `Content-Type` = "application/json"
    ) |>
    httr2::req_body_json(list(
      model = "gpt-4o-mini",
      messages = list(
        list(role = "system", content = ISCO_RULES),
        list(role = "user", content = prompt)
      ),
      temperature = 0,
      response_format = list(type = "json_object")
    )) |>
    httr2::req_perform()
  body <- httr2::resp_body_json(r, simplifyVector = FALSE)
  if (!is.null(body$error)) {
    msg <- body$error$message %||% "Unknown OpenAI API error"
    stop(msg)
  }
  if (is.null(body$choices) || length(body$choices) == 0) {
    stop("No choices returned by API")
  }

  content <- body$choices[[1]]$message$content
  if (is.null(content) || !nzchar(content)) {
    stop("Empty message content returned by API")
  }
  parsed <- jsonlite::fromJSON(content, simplifyVector = TRUE)

  needed <- c("isco4_code","isco4_label","isco3_code","isco3_label","position_english","notes")
  for (k in needed) if (is.null(parsed[[k]])) parsed[[k]] <- NA_character_

  parsed
}


# Safeguard wrapper 
isco_code_safe <- function(position, company = NA_character_) {
  tryCatch(
    isco_code_one(position, company),
    error = function(e) {
      warning("Failed for position: ", position, " | Error: ", e$message)
      return(list(
        isco4_code = NA_character_,
        isco4_label = NA_character_,
        isco3_code = NA_character_,
        isco3_label = NA_character_,
        position_english = NA_character_,
        notes = paste0("Error: ", e$message)
      ))
    }
  )
}

```

## Apply Function

```{r}
# Apply function to my data
isco_code_df <- function(df, position_col = "Position", company_col = "Company") {
  if (!(position_col %in% names(df))) stop("Missing column: ", position_col)
  if (!(company_col %in% names(df))) df[[company_col]] <- ""

  out_list <- mapply(
    FUN = function(pos, comp) isco_code_safe(pos, comp),
    df[[position_col]],
    df[[company_col]],
    SIMPLIFY = FALSE
  )

  out_df <- bind_rows(lapply(out_list, as.data.frame))

  bind_cols(df, out_df)
}

# Run the data through the API 
result <- isco_code_df(df_panel, position_col = "Position", company_col = "Company")

#save 
# write.csv(result, "result.csv", row.names = FALSE)
```

## Compare Results to Manual Coding

```{r}
# Load manual coding
result <- read_csv("")
jobs_with_id <- read_csv("")

# add ID to both for matching
result <- result |> 
  mutate(id = row_number())
jobs_with_id <- jobs_with_id |> 
  mutate(id = row_number())

# merge datasets
joined_df <- jobs_with_id |> 
  left_join(result, by = "id")
joined_df <- joined_df |> 
  mutate(isco4_manual = `ISCO 4 digit`)

#write.csv(joined_df, "joined_df.csv", row.names = FALSE)
```

```{r}
# Calculate percent match
accuracy_levels <- joined_df |> 
  mutate(
    isco4_code   = str_squish(isco4_code),
    isco4_manual = str_squish(isco4_manual)
) |> 
  filter(!is.na(isco4_code), !is.na(isco4_manual)) |> 
  summarise(
    accuracy_1digit = mean(substr(isco4_code, 1, 1) == substr(isco4_manual, 1, 1)) * 100,
    accuracy_2digit = mean(substr(isco4_code, 1, 2) == substr(isco4_manual, 1, 2)) * 100,
    accuracy_3digit = mean(substr(isco4_code, 1, 3) == substr(isco4_manual, 1, 3)) * 100,
    accuracy_4digit = mean(isco4_code == isco4_manual) * 100,
    n = n()
  )

accuracy_levels
```
